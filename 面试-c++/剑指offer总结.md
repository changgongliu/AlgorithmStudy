# 链表
    1. 链表倒数第k个节点采取滑动窗口解决。
    2. 链表翻转：采取新建NULL，从原链表上一个一个摘下来。
    3. 合并两个排序的链表：采取两个索引同时进行。 或者 递归的方式。
        - 需要考虑空指针的情况
    4. o(1)时间删除节点，只能是将下一个节点的值赋给当前节点，删除下一个节点
        - 是尾节点
        - 只有一个节点，直接删除
        - 非上述情况
    5、 调整数组顺序，使得奇数位于前边，偶数位于后边，并保证各自相对位置不变。
        - 快排的思想不稳定，导致顺序不正确。
    6、二叉树镜像：判断是否为当前是否空，对当前节点子节点进行反转。
    7、打印矩阵--？？？？？？？？？？？？？未能解决
    8、 二叉树的后序遍历--建立索引，<为一部分，>为一部分，然后分别进行判断。维护好索引值。
    9、 字符串的排列，调用set数据类型。进行递归式的排序。
    10、第一次只出现一次的字符
        - 用map的话，向map中插入字符顺序是打乱的，不能以map中先后顺序来区分第一个还是后来的；
        - 对于string的遍历，i的类型为stirng::size_type
    11、 按字典序打印字符串中字符的所有排列
        - 要先去重，牛客网上测试用例有问题。
        - 采用递归方式，当begin == end时，表示一个交换完成
        - 相同字符跳过。
        - 最后进行排序按照字典序。
    12、 二维数组中的查找-从右上角进行查询，进行判断，大于target就一次列--，其他行++找到最后答案
    13、 替换空格问题-扩展内存，进行倒序复制。
    14、 从尾到头打印链表-进行递归式添加，先遍历然后进行添加。
        - 迭代采用栈的形式。
        - 递归结束条件 当当前节点为NULL时结束。
    15、 用两个栈实现队列
        - 辅助栈出完后，在进行压栈。
    16、 旋转数组的最小数字-----------------------------？？？？
        - 近乎有序数组，考虑快排方式。
        -
    17、 把数组排列成最小的数，调用库函数sort，自己写一个两个数比较的函数，进行排序，然后进行串联输出。
        - 定义的比较函数须是static函数。（为什么？？？？？？？？？？？？？？？？？？？？？？）
        - 考虑大数溢出的问题。

    18、 二叉搜索树与双链表问题。
        - 采用中序遍历，增加一个指针引用，每次存储当前最后一个节点。
        - 在中间步骤，进行处理，对最后一个节点进行指向调整。
    19、复杂链表的复制
        - 首先进行链表复制，然后将新节点连接在相应点后边
        - 进行random链接
        - 拆分链表
        - 问题总结：
            - 对于next在while中需要判断进行判断
            - 进行防御式编程，每一个指针都要小心为空
            - 对于next问题可以先取next，然后判断是够为空
    20、两个链表的第一个公共节点
        - 采用栈，进行倒序判断节点。
            - 空间复杂度o(m+n),时间复杂度o(m+n)
        - 第二种方法:将两个链表一样长，进行对应比较。（分析规律，进行比较）。
    21、 删除链表中重复的结点
        - 加一个索引，保存前一个索引与当前索引，进行遍历，将要删除的进行删除。
    22、 数组中出现次数超过一般的数字
        - 涉及到中位数的问题，快排返回的中间数字如果与原数组中位数相等，则肯定是这个数字。
            - 时间复杂度：o(n)不理解？？？？？？？？？？？？？？？？？？？？？
        - 另一种思路：数学规律：
            - 保留两个数值，一个数字，一个次数
            - 当次数为0时，数字表示当前数字，次数加一
            - 当当前与前一次数字相同，次数加一
            - 当当前数字与前一次数字不同时，次数减一。
            - 只有一个数，就是次数大于一般的数字可以做到最后次数大于0。
    23、 最小的k个数
        - 首先进行排序，然后得出最前k个数字。
    25、丑数：保存三个索引，每个索引，指向当前*对应值的最大索引，每次插入三个值中最小值。
    26、 数组中只出现一次的数字。
        -
    27、 平衡二叉树，判断一棵树是不是平衡二叉树
        - 后序遍历，先判断左子树、右子树，在判断本身，这样就只遍历了一遍。
        - 当二叉树为空时，是平衡二叉树。
    28、 和为s的连续正数序列
        - 设置一个索引，保存左值，设置一个变量进行遍历，将中间值进行相加，得到最后结果满足条件就进行添加
    29、和为S的两个数字
        - 开始还在纠结乘积最小，后来转念一想，a+b=sum,a和b越远乘积越小，而一头一尾两个指针往内靠近的方法找到的就是乘积最小的情况。如果是乘积最大的情况就是一直找到两个指针重合，每次找到一个就将之前返回的结果向量清空然后更新为新找到的。
        -
    30、翻转单词顺序序列
        - 首先进行整个字符串反转
        - 然后进行单词翻转。
        - 使用迭代器时注意最后一个单词没有翻转，要进行翻转
    31、左旋转字符串
        - 进行三次reverse即可实现功能。
    32、 ？？？？？1+2+。。n不能使用各种限制。

    33、表示数值的字符串。
        - 进行所有情况进行考虑
    34、 正则表达式匹配
        - 对*的考虑，将整个程序分为两部分。
        - 第一部分：略过pattern2个字符，匹配下一个字符
        - 第二部分：对下一个字符进行匹配，pattern模式进入下一个模式，或者还在当前状态
        - 剩下考虑字符相同或者pattern为‘.’的情况
    35、 扑克牌顺子
        - 首先进行排序，统计0的个数，在统计相邻数字之间的差距，把两个数据进行比较
        - 注意：当两个数相等时，返回false
    36、 按之字形顺序打印二叉树
        - 创建一个队列，将每层存入结果中
        - reverse偶数层结构即可
    37、重建二叉树
        -
//leetcode前序、中序、后序遍历
# 二刷有问题的题，未能做到鲁棒性
1. 用两个栈实现队列
2. 旋转数组的最小数字  ？
    - 理解上有问题。
3. 斐波那契数列非递归方式，运算的时候遇到问题。
    - 采用for循环，保存每次运算中间值，依次递增
4. 二进制中1的个数
    - 负数用补码表示，负数用补码，所谓补码就是除符号位，取反再加一
5. 数值的整数次方
    - 未实现代码的鲁棒性
    - 先计算正值的次方，计算的时候每次计算一半，采用递归的方式。
6. 










































































































    18、
