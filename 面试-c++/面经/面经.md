# 柠檬微趣 c++开发-后台服务器
1. 关于虚拟地址的问题
2. 虚函数表存储在哪里，怎么进行调用。
    - C++中的虚函数的作用主要是实现了多态的机制。
        - 关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。
        - 所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。
    - 在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了
    - C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置
    - 总结：存在于每一个实例中
    - 无覆盖继承：虚函数按照声明顺序存在于表中，父类虚函数在子类虚函数前边。
    - 有覆盖继承：覆盖的f()函数被放到了虚表中原来父类虚函数的位置，没有覆盖的函数依旧。
    - 多重继承-无覆盖继承：每个父类都有自己的虚表，子类的成员函数被放到了第一个父类表中（所谓的第一个父类是按照声明顺序来判断的)
    - 多重继承-有覆盖继承：所有父类虚表中原来虚函数的位置被替换为子类函数指针。
    - 另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。
    - 虚表不存在具体实体中，虚表指针存在具实体中。
    - 虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\0”一样，其标志了虚函数表的结束
3. 虚拟地址存在的意义 -- 方便与管理，类比于机器语言和高级编程语言，但是真正操作的还是物理地址。
4. 对普通树的遍历，得到最大宽度----？
5. free掉地址后，表示本地址可以被回收了，但是在没回收前还是可以访问的。
6. 快排的优化
    - 当重复数据比较多，快速排序就会退化到o(n^2)级别，导致分成的两部分极度不均匀。采取双路快排，两个索引从前后同时向中间聚拢，知道l对应值》=V,r对应值《v，将两个值进行交换，l++，r--，将=V的分到了两部分，进行快排，不存在大量=V的元素集中在某一部分。
    - 三路快排，三个索引，分为<V,=V,>V的部分，=V的部分不需要进行排序。=v不进行操作，<v,lt++，交换位置，>v,gt --， 交换位置。
7. 堆排的时间复杂度：平均情况下 O(nlogn),不稳定，冒泡排序o(n^2)
8. c中申请内存的方式：
    - 内存的分配方式：
        - 静态存储区进行内存分配， 内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量
        - 在栈中进行分配： 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储但愿自动被释放。效率很高，但是分配的内存容量比较有限
        - 在堆中进行分配：在堆上分配也成为动态分配，程序在运行的时候用malloc等函数申请任意多少的内存，程序员自己负责在何时用free释放内存。动态内存分配的生存期由我们自己决定，使用非常灵活，但是问题相对也比较多；注意：//如果没有释放的话，很容易就会造成内存溢出，因为堆中的内存块是全局的，因此不会因为函数的调用而结束
    - 动态分配时使用的函数：
        - malloc函数:需要用到的头文件malloc.h，允许从空闲内存池中分配连续内存但不初始化
        - free(p);//释放内存空间,将内存释放出来给系统；
        - 只要没有调用free这个函数，进程没有结束，那么此时，这个函数的生命周期就会一直存在在内存中；它是存放在堆空间中的，它不会因为你去函数调用的结束自动去释放，堆当中的内存是全局的
        - calloc函数:需要用到的头文件stdlib.h，功能同malloc是一样的，但是作初始化，也是需要与free(p)进行对称使用。
        - realloc函数:需要用到的头文件(stdlib.h),动态扩大缩小申请的内存，在指针ptr指向的内存基础上扩大或者缩小内存，realloc在C语言中也被称为动态数组； 若第一个参数为NULL那么功能 等同与malloc函数，若第二个参数为0,那么会释放调用内存块
            - 当缩小或者扩大内存时，一般不会对其进行移动，若无法扩大内存块，那么会在别处分配新的内存快，然后把旧内存块的数据复制到新块 中，并将旧块删除释放内存；
        - free之后如果还有这块内存地址的话，此时这块内存归还给了系统，（可能这块内存还处于一个空闲状态）但是还是可以对其进行操作。里面的值短暂的会保留。
        - free之后，申请内存的那个指针就会变成野指针(声明了，但是没有任何指向的指针)，有时候会出现野指针错误；
        - 所以尽量在操作之后：将指针置为NULL
        - 野指针的形成是指针变量没有被初始化，任何指针变量刚被创建的时候不会自动成为NULL指针，它的缺省值是最忌的，它会乱指一气
        - 指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法内存
        - free内存块之后，需要将指针设置为NULL，如果没有设置为NULL，也会出现“野指针”，它是指向“垃圾”内存的指针；
        - 多次free内存块，是会导致程序崩溃的
9. 数据库处理大量数据查询，数据库本身数据量很大。
    -
# 京东云
1. 大文件字符串处理问题还很欠缺。


# 阿里云
1. 虚函数表是全局共享的元素,即全局仅有一个，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享,大小确定.所以我推测虚函数表和静态成员变量一样,存放在全局数据区.
    - 栈区,堆区,程序代码区,全局数据区(静态区),文字常量区.
    -
2. 死锁的必要条件：
    - 互斥条件：一个资源只能被一个进程占用
    - 请求与保持条件：一个进程以为请求资源而堵塞时，对已获得请求的资源保持不放
    - 不可剥夺性：进程已获得的资源，在未使用完前，不能被强行剥夺
    - 循环等待条件：若干进程形成一种头尾相连的循环等待资源的关系
3. 如何判断一个链表有环：
    - 开辟空间来存储指针，便利新指针与存储指针进行比对，若有相同指针，则有环
    - 快慢指针，来实现。
4. 模式一定要看啊
    -
5. Linux查看磁盘占用空间的命令，查看进程占用内存的命令
    - df -ah磁盘占用情况
    - free -m 查看服务器内存使用情况
    - linux 查询进程占用内存的方法总结,rss物理内存
        - status   ， cat /proc/PID/status
        - pmap -x  , pmap -x 25282
        - smaps    , cat /proc/PID/smaps
        - ps       ,
        - top 命令
            - p, 按照cpu排序
            - M， 按照占用内存（memory排序
        - top命令
    - 操作系统如何限制线程数目
        -
6. 动态规划和贪心算法的区别
    - 不同点：
        - 每一步的最优解一定包含上一步的最优解
    - 动态规划：
        - 全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解
    - 贪心算法：
        1.  不能保证求得的最后解是最佳的；   
        2.  不能用来求最大或最小解问题；   
        3.  只能求满足某些约束条件的可行解的范围。实现该算法的过程：   
    - 最优解问题大部分都可以拆分成一个个的子问题，
    - 动态规划： 动态规划与分治非常像，都是要把大问题分解，然后再将小问题的解合并起来得到大问题的解
    - 动态规划：（A+B）最优
7. 二叉树非递归遍历
    - 创建栈，先将所有左孩子入栈，直到左孩子为空，将栈顶元素出栈，然后输出当前值，将栈顶元素右孩子压栈，重复上边操作，直到p为NULL并且栈为空遍历结束。
8. c++虚函数底层实现原理：
9. 函数读进一个文件，问这个文件存在什么位置。
10. 多继承的时候，父类有相同的函数，子类继承那个函数
    - 都会继承，至于在内存中出于什么状态，不知道，可以采用类名和域解析符::分别调用。以显式地指明到底使用哪个类的成员，消除二义性。
    - 多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。
    - 基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。
    - 多继承形式下析构函数的执行顺序和构造函数的执行顺序相同。
11. 内存的分配--还要研究
    - 静态存储区。内存在编译时就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量。
    - 栈函数内部局部变量在栈上创建，函数执行完这些存储单元自动释放。
    - 堆上分配，动态分配，生存期由我们自己决定。
12. c++编译链接的过程。 ----还要研究
    -
13. stl库某对象实例化过程
    -
14. 进程间通信
    -
15. vector实例化过程。
    -

## 总结面经
1. c++有哪些性质
    - 封装（实现隐藏的一种技术）、继承、多态
2. 子类析构时要调用父类的析构函数吗？
    - 析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数
3. 多态、虚函数、纯虚函数
    - C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；
4. 引用
    - 应用就是一个目标变量的别名，
    - 声明一个引用时，要对其进行初始化。
    - 引用本质上不占用存储单元，系统也不给引用分配存储单元。
    - 不能建立数组的引用。
5. 什么时候使用常引用 
    - 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。
6. 判断系统是32位的还是64位，用sizeof函数对于一个指针sizeof(p),返回值为4则为32位操作系统，打印结果为2则是16位。
7. 全局变量与局部变量的区别。
    - 生命周期不同，全局变量随着主程序创建而创建，随主程序销毁而销毁，内存分配在全局数据区。
    - 局部变量分在栈区。只存在局部和函数内部
    - 使用方式不同：通过声明后全局变量程序各个部分都可以用到，局部变量只能在局部使用
    - 操作系统和编译器通过内存分配位置知道。
        - 全局变量分配在全局数据取并且在程序还是运行时被加载。
        - 局部变量则分配在堆栈里
8. 内存对其问题
    - 为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。
9. 动态链接库的两种方式
    - 载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向系统提供了载入DLL时所需的信息及DLL函数定位。
    -  
10. 纯虚函数实现
    - 纯虚函数相当于占位符，先在虚函数表中占一个位置由派生类实现后再把真正的函数指针填进去。除此之外和普通的虚函数没什么区别。
11. 设计模式 ---还要研究

12. 有关重载函数
    - 相同的作用域中，
    - 函数参数个数或者顺序或者类型不同
    - 不能考返回类型进行判断
    - virtual关键字可有可无
    - 对于非引用传参，是否为const是一样的
    - 使用引用传参是，有无const是不同的
    - 使用指针传参是，指向const对象的指针和指向非const对象的指针做形参函数是不同的
    - 关于const重载，即函数的const重载
        - 是不同的隐含的this指针形参进行重载。
        - const对象调用const函数，普通对象都可以调用，一般调用非const函数。
13. class与struct的区别
    - （一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；
    - （二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。
除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。
14. stack
    - 首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区
        - 隐藏体现在：在本模块声明的变量只能在本模块使用，在本模式生命的静态函数只能被本模块其他函数调用。
15. volatile
    - 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
16. const
    - 意味着只读。
17. 怎知道内存泄漏
    - 在内存分配器前面套一层，记录所有的分配和释放，然后就可以在程序退出的时候知道哪些内存没有释放。
18. 指针复制，只是指向的空间是相同的，并不是指针是相同的
19.
