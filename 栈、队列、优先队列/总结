# 递归算法-二叉树中算法
1. 前序遍历-在前序位置做事情
  - 中序遍历-在中序位置做事情
  - 后序遍历-在后序位置做事情
2. 队列queue
  - 广度优先遍历
  - 树；层序遍历
  - 图：无权图的最短路径
3. 对于堆的底层实现，白板编程
  - c++ priority_queue
  - 定义在queue中
  - 默认情况下，最大堆
  - priority_queue<int, vector<int>, greater<int>> 最小堆
  - myCmp(int a ,int b){ }
  - priority_queue<int, vector<int>, function<bool(int, int) >> pq3(myCmp);
4. set和map常见操作
  - insert、find、erase、change(map)
  - record.find(num2[i]） != record.end()
  - 哈希表进行底层实现，在插入、删除、查找o(1)时间复杂度
  - 二分搜索树时间复杂度都为o(logn)
# 二叉树和递归
1. 二叉树天然的递归结构
  - 递归终止条件，递归过程
  - 空是一棵二叉树
2. 一个简单二叉树问题引发的血案
3. 注意递归的种植条件 path sum
4. 定义递归问题binary tree path
5. 稍复杂的递归逻辑
    - 437
    - 二分搜索树插入、查找、删除方式
    - 235
- 二叉搜索树-若存在左右子节点，则左子树所有节点小于根节点，根节点小于右子树所有节点

# 动态规划-dynamic planing
1. 什么是动态规划
    - 将原问题差结成若干子问题，同时保存子问题的答案，是的每个字问题只求解一次，最终获得原问题答案。
    - 菲波那切数列
        - F(0)=1,F(1)=2, F(n)=F(n-1)+F(n-2)
        - 记忆化搜索-自上向下的解决方法问题
        - 递归问题
2. 70 climinbing stairs
3. 120
4. 343
    - 可采用回溯便利讲一个数做分割的所有可能性，O(2^n)
    - 分割，求子问题最优解，获得原问题最优解
# 贪心算法
1. 455题,进行排序sort(g.begin(), s.end(), greater<int>())从大到小进行排序
    - 练习题392、

# 二叉树
1. 98 定义最大最小节点，向下传递。进行判断
2. 

# 树形问题
## 17 letter combinations of a phone number
1. 问题
    - 字符串合法性
    - 空字符串
    - 多个解顺序
2. 

# 动态规划
1. 菲波那切数列
    - 对于重复计算只计算一次
    - 时间复杂度：

## 背包问题-贪心算法
1. F(n, C) 表示n个物品放进容量为C的背包，是的价值最大
    - F(i, c) = F(i-1, c) || v(i)+F(i-1, c-w(i))
    - 使得F(i,c)最大，则max( F(i-1, c) , v(i)+F(i-1, c-w(i)) )
    - 记忆化搜索 方法
    - 自底向上的0-1背包问题
        - 建立一个二维数组，从第一个开始填充 
2. 发现重叠子问题
    1. 343
        - 子上而下分割子问题，解决重叠子问题
        - 最优子结构
    2. 递归问题-》重叠子问题-》记忆化搜索
                 最优子结构-》动态规划
### 状态定义和状态转移
1. 198 house Robber
    - 状态：考虑偷取[x....n-1]范围里的房子
    - 定义状态转移
        - f(0) = max { v(0)+f(2), v(1)+f(3)......, v(n-1)}
    - 使用心得状态转移方程。