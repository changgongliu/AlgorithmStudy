# 为什么学习算法
## 一、o(n`2)时间复杂度算法
1. 算法无处不在
2. 学习算法，才能创造更有意义的东西
3. 算法与与语言无关
4. 白板编程 锻炼编程能力
5. 算法+数据结构=编程
6. 实用精巧算法解决计算机程序是美的。
## 排序算法
1. 为什么学习O(n`2)
2. 选择排序
    - o(logn`2)
    - 加入模板，使用模板让程序更灵活
3. .h文件编译后不对外隐藏，.cpp文件进行隐藏。
4.  随机生成算法测试用例
    - 自己命名声明空间
    - 创建指针，开辟了空间要进行释放，不释放会出现潜在的内存泄漏。
    - 数组类型释放空间。delete[] arr;
5. testSort测试排序
    - 传入函数指针
6. 插入排序
    - copy数组,copy(a, a+n, arr)
    - 平均o(n`2)时间复杂度
    - //* 在VS中, copy函数被认为是不安全的, 请大家手动写一遍for循环:)
    - 可以提前终止循环
    - 近乎有序的排序，插入排序近乎o(n)时间复杂度
7. swap一次交换就是三次赋值
    -  占用空间，花费时间
8. 冒泡排序
    - 时间复杂度：o()
    - Bubble sort
    - 自学一下。
9. 插入排序-》希尔排序（shell sort）
    - 互联网，了解希尔排序，实现一下
    - 与插入排序一脉相传
10. 排序最佳时间复杂度：o(nlogn)
## 二、o(nlogn)时间复杂度-高级排序算法
1. 归并排序-merge sort
    - 分成两半排序（排序完），重在归并
    - 层数logn
    - 每一层要出来的数据都是n
    - 时间的效率比空间的优先级要高。
    - 排序过程，与归并过程。
    - 优化
        - 在低于一个值的数组中采用插入排序要比归并排序来的简单。
        - 近乎有序插入排序时间复杂度近乎o(n)
    - 使用递归实现自顶向下的归并排序-以上过程
    - 自底向上归并排序
        - 没有对数组索引的使用，可以使用这个排序算法作用到链表，进行排序，实现o(nlogn)的时间复杂度
        - 只需要迭代不需要递归
2. 快速排序-quick sort
    - partition把数组分成两部分
    - 一般把数组第一个元素，把数组分成两部分
    - 将大的部分第一个与小的部分最后一个元素进行位置交换
    - 将数组分成两部分称为partition
    - 思想
        - l记录当前选择的分组值
        - j记录当前小于v的部分最后一个值位置
        - i指向当前值
        - e当前值
        - e>v直接i++即可，小于v与>v部分第一个元素交换位置
        - 最后把l与j进行交换位置
    - 优化一：当数组长度小与等于16时，采用插入排序算法。近乎有序，插入算法是个美妙的算法。可以很好的解决近乎有序的算法进行排序时，导致迭代过程导致的栈溢出。
    - 优化二：随机化选择标志位。
    - 优化三：小于等于，大于等于都会把数组分成极度不相同的两部分
        - 双路快速排序法
        - 从两头同时开始，两个遍历变量
    - 优化四：三路快速排序
        - 在大量重复数据排序中，远远快于归并排序和两路排序方法。
        - 没有重复键值，两路排序快于三路排序
3. mergesort 和quick sort的衍生问题
    - 分值算法，分而治之，江源文体，分割成同等
    - 逆序对数量   ？？？？？未实现
        - 暴力解法：考察每一个数对，碎发复杂度：0（n`2）
        - merge sort思路求逆序对的个数
4. 去除数组中第n大的元素 ？？？？？？未实现
    - 去数组中最大值，最小值 - o(n)
    - 取数组中低n大的元素。 - 有快拍可以实现0(n)时间是复杂度
## 三、堆排序 heap sort
1. 优先队列
    - 出对于入队顺序不同，与优先级相关
    - 为什么使用优先队列：
2. 对于n个请求：
    - 使用普通数组或者顺序数组，最差：o(n`2)
    - 使用堆：o(nlogn)
3. 堆中的基本实现-一种数据结构
    - 二叉堆-binary heap(二叉树)
        - 任何一个节点都不大于父节点
    - 最大堆
        - 二叉树是一棵完全二叉树
        - 优先集中在左侧。
        - 用数组存储二叉堆
        - 左节点为父节点二倍，有节点为父节点二倍+1
    - shift up
    - shift down
        - 从对中取出一个元素
        - 取出第一个元素，将最后一个元素放入第一个元素，进行shift down
        - 与子节点中较大的交换位置
    - 更多地用于动态数据维护。
    - 将n各元素逐一插入一个空堆中，算法复杂度是o(nlogn)
    - heapify的过程，算法复杂度为o(n)
    - 原地堆
        - 不需要额外的开辟空间、进行赋值开销
        - 从1开始索引，经典堆算法，从0开始索引
4. 排序算法总结
类型 | 平均时间复杂度 | 原地排序 | 额外空间 | 稳定排序
---|---|---|---|---
插入排序 | o(n`2) | 支持 |  o(1) | 稳定
归并排序 | o(nlogn) | 不支持 | o(n) | 稳定
快速排序 | o(nlogn) | 支持 | o(logn) | 不稳定
堆排序 | 0(nlogn) | 支持 | o(1) | 不稳定
- 稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。
- 相等元素的相对位置没有发生改变
- 排序算法的稳定性 stable
    - 可以通过自定义比较函数，让排序算法不存在稳定性的问题。
    - 稳定排序通常选择归并排序
- 满足最好的排序，到目前为止还不存在。理论上应该是有的。
5. 其他排序-自行研究
    - 冒泡排序
    - 希尔排序
6. 堆索引-index heap、
    - 元素结构复杂，交换元素会消耗大量的资源。
    - 存储的是索引号
    - 构建堆，只交换索引，数据不动
    - change 索引堆
        - 增加一个数组保存索引在队中位置。
        - 加入反向查找，是查找为logn时间复杂度。
7. 堆相关的几个问题
    - 使用堆实现优先队列
    - 多路归并排序
    - 最大堆，最大索引堆-》最小堆，最小索引堆
    - shiftUP与shiftDown使用赋值操作替换交换操作
    - 对的数组从0开始索引
    - 没有capacity的限制，动态的调整对中数组的大小
    - 最大、最小队列
    - 二项堆
    - 斐波那契堆
## 四、二叉搜索树-ninary search tree
1. 二分查找法
    - 对于有序数列，才能使用二分查找法
    - bug会处在l+r/2,当l与r很大时，会导致溢出。
    - 也可以通过递归的方法是先二分查找法。
    - 递归思维更容易，递归性能会差一些。
    - 二分查找法的变种
        - floor与ceil函数。
        - 数组中出现重复元素，floor找到的是v在数组中第一次出现的位置，ceil找到v在数组中最后一次出现的位置。
2. 二分查找树
    - 优势
        - 查找表的实现-字典数据结构
        - 高效-动态维护数据
    - 二叉树-每个节点键值大于左孩子，小于右孩子，以左右孩子为根的子树，依然为二分查找树。
    - 不一定是完全二叉树。
    - 查找与插入操作。
    - 最好的做法，隐藏数据结构。
3. 二分搜索树的前中后序遍历-深度遍历-o(n)
    - 每个节点可以分为三个位置：前中后位置
        - 前序：进行前中后序访问，前序位置进行操作
        - 中序：进行前中后序访问，中序位置进行操作
        - 后序：进行前中后序访问，后序位置进行操作
4. 二叉树层序遍历-广度优先遍历-o(n)
    - 引入双向队列
5. 二分搜索树 删除值-o(logn)
    - 删除最大值最小值所在节点
    - 删除一个节点。
    - 时间花费在查找节点中。
6. 二分搜索树的顺序性
    - 找到一组数据中最大最小值
    - 前驱与后继
    - floor、ceil
        - floor最接近45的值，小于45
        - ceil最近接45的值，大于45
    - rank 某一个key排名第几。
        - 更改node
    - select 排名第几的元素是谁
    - 支持重复元素的二分搜索树
        - 更改node结构
7. 二分搜索树的局限性
    - 时间性能上局限性。
        - 同样数据可以对应不同的二分搜索树
        - 二分搜索树可能退化成链表，o(n)
8. 树形问题和树
    - 归并排序
    - 快速排序
    - 搜索问题-8数码-搜索树
    - 更多树
        - KD树
        - 区间树
        - 哈夫曼树
## 五、并查集-union find
1. 并查集基础
    - 连接问题-connectivity problem
        - 网络中节点间的连接状态
            - 网络抽象的概念：用户之间形成的网络
        - 数学中的集合类实现
    - 路径问题：
        - 连接问题比路径问题要回答得少
        - 二分查找作比较
        - 和select作比较
        - 和堆比较
2. 并查集 quick find
    - 对一组数据，主要支持两个动作
        - union(p,q)
        - find(p)
    - 时间复杂度o(1)
    - union操作
        - o(n`2)时间复杂度
3. 并查集另一种实现思路
    - 将每一个元素，看作是一个节点
    - 增加parent指针，parent指向的是父亲节点，当指针指向自己说明自己为根节点。
    - 实现整个过程。
4. 基于size的优化
    - 将元素少的集合并到元素多的集合，减少树的层数
    - 但是并不是完全准确。
5. 基于rank的优化
    - rank[i]表示根节点为i的树的高度
    - 对只有会改变树高度的函数进行维护
6. 路径压缩 path compression
    - 对find进行优化
    - 没有找到根，就将树的高度减少一，进行路径压缩
    - 采用递归的方式
    - 理论与实践会有出入，根据实际情况选择最优的方式。
7. 并查集的操作，时间复杂度近乎是o（1）
    - 栈(stack)与堆(heap)
## 图论 对基础数据结构进行利用。 - graph theory
1. 节点和边
    - 应用
        - 交通运输
        - 社交网络
        - 工作安排
        - 互联网
        - 脑区活动
        - 程序状态执行
    - 图的分类
        - 一种方式
            - 无向图
            - 有向图
            - 以无向图为主
            - 无向图是一种特殊的有向图
        - 另一种方式
            - 无权图-Unweighted graph
            - 有权图- weighted graph
    - 问题
        - 图的连通性
            - 连通与否
        - 简单图(没有以下两部分)
            - 自环边-self loop
            - 平行边- parallel edges
2. 图的表示
    - 邻接矩阵
    - 邻接表
        - 表示当前与某一点相连的节点。
    - 邻接表适合表示稀疏的图
    - 邻接矩阵适合表示稠密图
        - 每一个节点数相连边的数目
        - 稠密图和完全图
3. 相邻节点迭代器
    - 遍历邻边
        - 邻接矩阵
            - 需要遍历
        - 邻接表
            - 不需要遍历所有元素
4. 图的算法框架
5. 图的遍历
    - 深度优先遍历
        - 需要记录每个节点是否被遍历，因为有环。
6. 寻路
    - 图的深度优先遍历-复杂度
        - 稀疏图（邻接表）：o(V+E)
        - 稠密图（邻接矩阵）：o(V^2)
    - 深度优先遍历算法对有向图依然有效
7. 广度优先遍历和最短路径
    - 建立队列
    - 将起点放入队列，将临节点放入队列，处理一个节点加入该节点未访问的临节点放入队列。
    - 层序优先遍历
    - 广度优先遍历求出了无权图的最短路径
    - 时间复杂度
        - 稀疏图- o(V+E)
        - 稠密图- o(V^2)
8. 迷宫生成，ps抠图-更多无权图的应用
    - flood fill
        - 抠图-将此连通分量标记出来
        - 扫雷
    - 走迷宫
    - 迷宫生成
        - 迷宫生成是一个生成树的过程
    - 欧拉路径
        - blue path
    - 哈密尔顿路径
        - 地图填色
## 最小生成树-带权图
1. 有权图
    - 
