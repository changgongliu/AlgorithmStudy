# 递归算法-二叉树中算法
1. 前序遍历-在前序位置做事情
  - 中序遍历-在中序位置做事情
  - 后序遍历-在后序位置做事情
2. 队列queue
  - 广度优先遍历
  - 树；层序遍历
  - 图：无权图的最短路径
3. 对于堆的底层实现，白板编程
  - c++ priority_queue
  - 定义在queue中
  - 默认情况下，最大堆
  - priority_queue<int, vector<int>, greater<int>> 最小堆
  - myCmp(int a ,int b){ }
  - priority_queue<int, vector<int>, function<bool(int, int) >> pq3(myCmp);
4. set和map常见操作
  - insert、find、erase、change(map)
  - record.find(num2[i]） != record.end()
  - 哈希表进行底层实现，在插入、删除、查找o(1)时间复杂度
  - 二分搜索树时间复杂度都为o(logn)
# 二叉树和递归
1. 二叉树天然的递归结构
  - 递归终止条件，递归过程
  - 空是一棵二叉树
2. 一个简单二叉树问题引发的血案
3. 注意递归的种植条件 path sum
4. 定义递归问题binary tree path
5. 稍复杂的递归逻辑
    - 437
    - 二分搜索树插入、查找、删除方式
    - 235
- 二叉搜索树-若存在左右子节点，则左子树所有节点小于根节点，根节点小于右子树所有节点

# 动态规划-dynamic planing
1. 什么是动态规划
    - 将原问题差结成若干子问题，同时保存子问题的答案，是的每个字问题只求解一次，最终获得原问题答案。
    - 菲波那切数列
        - F(0)=1,F(1)=2, F(n)=F(n-1)+F(n-2)
        - 记忆化搜索-自上向下的解决方法问题
        - 递归问题
2. 70 climinbing stairs
3. 120
4. 343
    - 可采用回溯便利讲一个数做分割的所有可能性，O(2^n)
    - 分割，求子问题最优解，获得原问题最优解
# 贪心算法
1. 455题,进行排序sort(g.begin(), s.end(), greater<int>())从大到小进行排序
    - 练习题392、

# 二叉树
1. 98 定义最大最小节点，向下传递。进行判断
2. 

# 树形问题
## 17 letter combinations of a phone number
1. 问题
    - 字符串合法性
    - 空字符串
    - 多个解顺序
2. 

# 动态规划
1. 菲波那切数列
    - 对于重复计算只计算一次
    - 时间复杂度：

## 背包问题-贪心算法
1. F(n, C) 表示n个物品放进容量为C的背包，是的价值最大
    - F(i, c) = F(i-1, c) || v(i)+F(i-1, c-w(i))
    - 使得F(i,c)最大，则max( F(i-1, c) , v(i)+F(i-1, c-w(i)) )
    - 记忆化搜索 方法
    - 自底向上的0-1背包问题
        - 建立一个二维数组，从第一个开始填充 
2. 发现重叠子问题
    1. 343
        - 子上而下分割子问题，解决重叠子问题
        - 最优子结构
    2. 递归问题-》重叠子问题-》记忆化搜索
                 最优子结构-》动态规划
### 状态定义和状态转移
1. 198 house Robber
    - 状态：考虑偷取[x....n-1]范围里的房子
    - 定义状态转移
        - f(0) = max { v(0)+f(2), v(1)+f(3)......, v(n-1)}
    - 使用心得状态转移方程。
### 0-1背包问题
    - F(n,c) 将n个物品放进C的背包中，使得价值最大
    - F(i,c) = max(F(i-1, c), v(i)+F(i-1, c-w(i)))  状态转移方程
    - 时间复杂度o(n*C)
    - 空间复杂度o(n*C)
### 0-1背包问题的优化和变种
    - 时间复杂度：o(n*c)
    - 空间复杂度：o(n*c)
    - 完全背包问题，每个物品可以无限使用
        - 转换有限使用的背包问题
    - 多重背包问题-每个物品不止一个，有num(i)个
    - 多维费用背包问题， 要考虑物品的空间和重量两个维度
    - 物品见可以互相排斥，也可以互相依赖
### leetcode中的01背包问题
    - 416 partition equal subset sum
    - 322、377,139、494
### 最长子序列问题-最长上升子序列问题
    - 300 给定一个整数序列，求出其中最长上升子序列
        - 子序列？上升？多个上升子序列，最长的只有一个
        - 相等是否上升
        - 暴力方法：所有子序列进行判断
        - longest increasing subsequence  LIS
        - LIS(i)表示第i个数字为结尾的最长上升子序列长度
            - 可使用数字[0...i]
        - LIS(i)=max( 1+ LIS(j) if nums[i]>nums[j])
        - 以上o(n^2)时间复杂度
        - o(nlogn)算法，不是动态规划算法
    - 例题：376(依然最长子序列)、

# 递归和回溯
## 数型问题
1. 17.letter combination of a phone number
    1. 树型问题
    2. s(digits[0..n-1]) = letter(digits(0)) + s(digits[1..n-1])
    3. 递归要返回
    4. 算法复杂度：
        1. 时间复杂度:o(2^n),与O(3^n)差别一个常数，表示一个级别
2. 回溯法是暴力解法的一个主要实现手段
    1. 93 restore ip addresses
        1. 见了他从的93题
    2. 131.palindrome partitioning
        1. 