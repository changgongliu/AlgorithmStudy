# 内存分配方式
1. 用free 或delete 释放了内存之后，立即将指针设置为NUL L ，防止产生“野指针”
2. 野指针成因：
    - 指针变量没有被初始化，他的缺省值会乱指一通，所以要初始化，要不指向NULL，要不指向合法内存。
    -
3. 操作系统自己处理new，malloc异常，不好，如果发生内存耗尽情况，一般应用程序已经无可救药，不采用exit(1)杀死坏程序，会害死操作系统。

## c中内存机制内存分为5个区：
    1. 栈
    2. 堆
    3. 全局/静态存储区，程序一经编译，该区域就存在，在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值
    4. c风格字符串常量存储区：专门存放字符串常量的地方，程序结束时释放。
    5. 程序代码区
### c++中内存机制
    1. 栈
    2. 堆，该堆是用malloc/calloc/realloc跟配，free释放，如果忘记释放就会导致内存泄漏，程序终结时由os回收
    3. 自由存储区：由new申请的内存，delete释放
    4. 全局区（静态区） ， 全局变量和静态变量存放区，已经编译好，该区域就存在。
    5. 常量存储区：专门存储不能修改的常量。
### 堆和栈有什么区别
    - 管理方式不同，栈有编译器进行管理，堆由程序员进行管理
    - 空间大小：堆得空间很大，几乎是没有限制的。但是栈的空间很有限。默认占空间是1M(VC下)
    - 能否产生碎片不同：在堆中频繁new/delete会产生碎片，会产生内存空间不连续，栈不会存在这个问题，栈先进后出，总是一一对应。总是连续的，不会从中间弹出
    - 分配方式：堆都是动态分配，栈有两种分配方式：静态分配，在编译器对局部变量进行分配时，动态分配有alloca完成，编译器总动回收。
    - 分配效率：栈是机器熊提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。
### 控制c++内存分配
    - 　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。
    - 过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。
    -
### 野指针成因
    - 指针变量没有初始化
        - 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气
    - 指针所指内存回收后，没有指向NULL，还使用此指针
    - 指针操作超越了变量的作用域范围
### 有了malloc/free后为什么还要new/delete
- 既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
### 内存耗尽怎么办：
    - 如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。
    -
### 类空间
1. 对象的大小是它的数据成员所占存储空间之和，就和结构体一样。类中的函数是所有该类对象通用的方法，不算作对象的成员，因此也不算在对象的存储空间内
2. 当类中类有定义任何变量的时候，类的对象都是1个字节的，当类中没有任何变量的时候，这个类里没有任何真正的成员变量，所以大小应该是0，但0大小不好在内存中定位一个地址，所以，就规定它大小为0的对象要占一字节空间，以便让它拥有一个合法的地址。如果是有派生类的，还有考虑到内存对齐的问题的。
3. A中只有一个或者几个虚函数的话，没有成员变量，那么类A相当于含有一个vptr指向虚函数表的指针，所以sizeof(A)=4。
4. 空类所占空间为一(上文以解释)，单一继承的空类空间也是1，多重继承的空类空间还是1，但是虚继承涉及到虚表(虚指针)，所以sizeof(D)=4。
2. A中只有一个或者几个虚函数的话，没有成员变量，那么类A相当于含有一个vptr指向虚函数表的指针，所以sizeof(A)=4。
### 自由存储区与堆区
1. 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
### 
